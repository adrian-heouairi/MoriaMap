private void TransportNetwork.getTimeWeightsAux(Vertex v, Map<Vertex, LocalDateTime> m):
    pour chaque arête e dans this.getOutgoingEdges(v):
        if e est un TransportSegment:
            tempsDattente = this.getPassages(v).getWaitTimeWithWrap(m.get(v).toLocalTime(), e.getVariantName(), e.getLineName())
            if tempsDattente == null: throw new IllegalStateException("Il n'y a pas de transports sur ligne + variant")
        else: tempsDattente = 0
        LocalDateTime nouveauTemps = m.get(v) + tempsDattente + temps de l'arête
        if e.getTo() n'existe pas dans m.keys() ou m.get(e.getTo()) > nouveauTemps:
            m.put(e.getTo(), nouveauTemps)
            this.getTimeWeightsAux(e.getTo(), m)

// Donne un poids à toutes les arêtes y compris les WalkSegment. Vertex start peut être un Stop mais aussi un GeographicVertex
public Map<Edge, Double> TransportNetwork.getTimeWeights(Vertex start, LocalTime startTime):
    var m = new HashMap<Vertex, LocalDateTime>()
    m.put(start, LocalDateTime.of(ARBITRARY_LOCALDATE, startTime))
    this.getTimeWeightsAux(start, m)

    var res = new HashMap<Edge, Double>()
    for v in this.getVertices():
        for e in this.getOutgoingEdges(v):
            if e est un TransportSegment:
                tempsDattente = this.getPassages(v).getWaitTimeWithWrap(m.get(v).toLocalTime(), e.getVariantName(), e.getLineName())
                if tempsDattente == null: throw new IllegalStateException("Il n'y a pas de transports sur ligne + variant")
                res.put(e, tempsDattente + e.travelDuration())
            else: res.put(e, e.walkDuration())

    return res